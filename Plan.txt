Misc:

   Stop using asserts for likely user errors. Parser is full of asserts that are actually faulty user data. Need to grapple with things now before they become more complex, even if in the future there is likelihood that things will change.
   Maybe do some fuzz testing? Especially for parsers
   Hard to reason with fixed buffer because we immediatly transform delay into a parameter string. Having to parse the delay is not a solution. Figure out what to do and remove all the portions of code that parse the delay out from the unit
   Should probably generate a FUInstance unit test, that runs an unit individually and make sure that the unit correctly implements the interface expected by Versat. The user simply calls a function with the unit it wants to test and it outputs a verilog testbench that exercises the unit. Most common sources of errors are gonna be delay = 0, not outputting done when done (the testbench should enter an infinite loop, do not know any other way to test this), following the specifications of the "iob" interface and the semi axi interface, among other things.

   Change the SizedString to simple String or Str. Change the UNPACK_SS to STR* or something more simple, if allowed.
   Change the CompareString functions to a operator ==
   Tired of having to write a lot for nothing. Also maybe remove the MakeSizedString functions. Probably no gain, especially if the alternative can be inlined in some way or form. Worse case generation call the function Str and call the struct String (or function is String and struct is Str or function is String and struct is string, maybe better this way, more explicit where it needs to). Have people call Str("") everywhere, if no good alternative exists.
   (Which doesn't appear to exist, because adding a constructor makes a mess with unions and I don't think an alternative exists)

Testbench:

   Rework testbench
      Add subtests
      Use a more data oriented approach. Kinda problematic when running in embedded, so make small changes and test in embedded to make sure not doing anything too much complicated.

Major change:

   A lot of the calculations being done in the FUDeclaration is already being done in the CreateFUInstance function of the Accelerator.
   This is actually expected. The registerSub function expects to receive an actual working Accelerator, and from them to generate a generic template instance.
   We make a couple of changes, like removing multiple inputs and adding delays, but somethings I think could be carried over, like static info and such

Graph optimizations:

   Adding the concept of weight to units would allow a number of optimizations to be performed, automatically by Versat.
      The calculate delay and fix graphs could potently replicate units if adding the delays would lead to a bigger overall weight.
      The weight could be simply set by the user for the simple units, while composite units would only need to add up all their instances weights.
      To calculate the weight, we could just compile the unit standalone and take the value of the amount of LUTs used.
      We could also add multiple weights, one for LUTs, another for memories, and so one.

Embedded data:

   The named access to FUInstances is actually the best way to go. 
      All we need is to separate the generation of the versat_data.inc file from the remaining of the code.
      This allows the user to separate the generation of versat from the test code.
      But on the other hand, we must force the user to always run the simulation code before compiling.
      Maybe add a debug flag to output all the data available anyway.

   Also consider adding a debug flag to output declaration data so that we do not need to tiptoe around it during the creation of tests.

Delay and Time:

   Introduce the concept of input delay and output delay.
      Represented in verilog by the wires delayInX, where X is the input port number, and delayOutX.
      delayIn is used for units that consume input and need to know when the input is valid. 
      delayOut is used for units that produce output and need to know when to start producing.
      The concepts of compute only, source, sink and source_sink can be derived from knowing which type each unit provides.

|  Add a "constant" edge, which is time agnostic (no buffer is ever added to a constant edge)
      Useful for units that produce a constant value.
      Maybe the concept should be applied to the unit itself, and not to the edge. But if so, it would be hard to propagate that info accross hierarquies. 
         For now, let the circuit designer handle this by setting himself the constant edges and stuff.
      Or maybe the concept should be applied to the port? The common use case would be a input unit, think const, that is connected to two other units with different delay requirements.
         The most important part is to make sure that we do not add buffer units for values that are constant from the moment unit starts producing valid data.
         Do not know how useful would a "constant" edge be in a world where we can already decide if the units port is constant or not. 
         Maybe when making accelerators where the final decision of when data is valid rests on the designer, and therefore no point in adding buffers.
            But in that case, maybe there is a better way of handling this cases? 

+  Remove base delay from FUInstance. Unneeded for multiple instances, should be replace by storing data on the FUDeclaration and/or temporarily on GraphData?
      A "hack" that shouldn't have been made, doesn't even work for merged accelerators, as we can have multiple base delays. Also delays should be port based, not instance based.

   Check how merging affects delay and buffer calculations.
      First thing I think is that for variable buffers, use an AcceleratorView and allow the function to only had delays units if the merging mapping needs it.
         The problem is that adding a buffer unit might affect the latency for previous circuits. Probably would get stuck looping around until no new unit was needed.
         Probably would need to do a full accelerator calculate delay and fix buffers, then use AcceleratorView for each graph to extract the correct values for each accelerator.
      For fixed buffers, I don't think using AcceleratorView does anything. Have to perform CalculateDelay and FixBuffers globally.

   Improve the fixing of graphs.
      When fixing the graphs, we currently only take the result from calculate delay and insert buffers into any edge with any positive delay.
      We can improve this by sending delay to later or units before hand. If a unit has 1 input and 8 outputs, and there is a need to delay to follow up units, then we end up adding 8 delay units when we only need to insert 1 at the input.
      I don't think this is a problem of the calculate delay algorithm, because if we had a unit with 8 inputs and 1 outputs, we could potentially hit the other edge case.
      I think we need to pick the result of the calculate delay as the base case, then model the problem as a minimization problem, knowing that we can shuffle delays around, until we reach a minimum of delay units needed to add. 

   Should the concept of data validity be extended to remove the fact that data is assumed valid forever after the unit starts producing valid data?
      Some units only produce valid data after X cycles. Think things like iterative units and complex FPU units that aren't pipelined.
      The concept is useful, especially if we can use it to make storing data to memory. It should also allow units that are not easily pipelinable to produce more than one valid data per iteration. 
      The problem is how to fix the timing for complex graphs. (Imagine a unit whose inputs produce valid every 2 cycles and another every 3 cycles).

   Further abstract the concept of iterative units. 
      Some units, like FPU div and such, work like iterative units.
      Ultimately, we use the concept of "iterative units" as a hack for the fact that Versat cannot represent units that only output valid data after every X cycles.
      It should be possible to define normal units as iterative, instead of only defined as graphs and through the use of ParseVersatSpecifications.

Performance:

   Need to check if the Hashmap class is producing good hashes. 
      The default c++ way of hashing was causing troubles as hashing pointers was completely useless
      As long as pointers are hashing correctly, don't think to much about it.

 Iterative units:
   
   Simplify the process of creating and make it more code based instead of versat specifications based.
      Develop a simple code path to create iterative units, also push the generation code to the codeGeneration file.
      Versat specifications should depend on 

Merge:

   Represent input and output mapping as specifics.

Configuration management:

   Add an interface to provide the user with the ability to save and load configurations.
      Need to add two types. Software sided saving and loading of configuration (Data is not stored on accelerator).
      Hardware sided saving and loading of configuration (Data is stored on accelerator).
      Provide ways to change from one side to the other.
      Provide ways to save data in PC-Emul and load it in embedded.
      Need to clearly separate where data is stored.

Parser:

+  Create a fuzzing test system to really hammer away parsing bugs.
      For starters, the test system takes a ordered collection of tokens already separated by the tester that is guaranteed to produce valid input.
      The fuzzer then uses that collection to produce a multitude of inputs that can potently fail 
      Random ways of producing failing inputs:
         Change order of tokens
         Insert whitespaces between random tokens
         Completely change the token with random garbage
         Completely replace token with whitespace (effectevely remove it)
         More specific: Insert at the start of the token a common character known to produce errors (ex: a digit, which usually cannot be found at a start of a identifier, etc.)
      Two things to test for: If the parser gracefully fails and if it produces a good error message, instead of simply asserting away.
      Override linux signal handlers to make sure we have actually output the test that cause the bug in the first place.
      We can add the fuzzer to the list of automatic tests that we continuosly run all the time. Use the compile time seed to make sure we can rerun the test later.


|  Change parsing of expressions to be much more correct, check some of the algorithms seen in the net. Make it explicit the precedence and associativity of operators

Optimizations:

   Profile the effects of the assertions in the code. Make sure debug mode isn't running too slow when compared to release
      Especial attention to the Array class operator[]. Taking a performance hit every time we access an array might cause problems later one. We can always replace the code when we actually reach that point, though.

   The RegisterSubUnit function is allocating space for every single units offset.
      This isn't needed, we could have if statements in the populate function that check wether the unit has actually need or not to have the field populated.
      In fact, currently units are having their configuration pointers point to somebody else configuration space. Ideally we should set the pointers to nullptr, as it should be a segfault accessing other units configurations.
      Also, investigate wether we need the offset arrays for outputs and extraData, instead of just using push pointers.

   The VCD file generation outputs data every cycle for every unit even if no change occured at all.
      The fix is farely easy, just pass an arena and store the previous outputted value, otherwise do not output anything at all.
      Probably takes longer, but uses less space and gtkwaves should load almost instantaneously 

Template:

   Do a template pass to remove duplicate code, lock down on the approach used to identify units and wires. Different templates should almost resemble each other. All the logic should be shared between units and should relie on common ground.
   Allow the use of enums inside templates. (See parsing enum info on Type)
   Add local variables. Need to introduce the concept of "stack frames".
   Take a look at the way whitespace is handled. Nothing too important, but I think some places could generate files with errors because they don't handle whitespace correctly

Type:

   Do a pass over the use of the temp identifier. It's kind of an hack 
   Parse and generate enum information.

Hashmap:

   Fix like the Pool fix (make it so the struct is like a viewer to the true data structure) and change to using buckets

Current know bugs/problems:

Legend:

   > Currently working on, important
   + Should be next, but taking a backseat to other, more important issues
   |  Subject to change, not final
   -  Not important, low priority or can be bypassed by hardcoding stuff until absolutely needed
