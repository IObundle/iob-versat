Versat is a Coarse Grained Reconfigurable Array (CGRA) IP core

## Cite this project

If you use this project please cite the following publication:

Lopes, J.D.; VÃ©stias, M.P.; Duarte , R.P.; Neto, H.C.; de Sousa , J.T. 
Coarse-Grained Reconfigurable Computing with the Versat Architecture. 
Electronics 2021, 10, 669. https://doi.org/10.3390/electronics10060669 


## Simulate

#Edit simulator path in Makefile and do:

```
make sim
```

## Compile FPGA 

#Edit FPGA path in Makefile and do:

```
source path/to/vivado/settings64.sh
make fpga
```

## Setup Verilator
- Install the Verilator simulator following the instructions in the 
[official page](https://verilator.org/guide/latest/install.html).
- Set the `VERILATOR_INCLUDE` environment variable in `$HOME/.bashrc`:
```
export VERILATOR_INCLUDE=<path>/share/verilator/include
```
  - The `<path>` to Verilator can be obtained with the command `which verilator` 
  after installation. For example if `which verilator` returns 
  `/usr/local/bin/verilog`, therefore: `<path>`=`/usr/local`. Final command:
  `export VERILATOR_INCLUDE=/usr/local/share/verilator/include`

# Versat Tutorial [4]

[MORE]
Versat is a tool that helps the automatic generation of coarse grain accelerators. 

[TOO VERBOSE]
Versat acts as a compiler, transforming a high level specification written in a custom language into an accelerator coded in verilog as well as C header files that defines the API to interface with the accelerator.

## Dataflow paradigm [6]

[MINOR REWRITE]
Versat describes accelerators using the dataflow paradigm. Computation is carried out by units that perform basic operations, like addition and multiplication, and data flows from unit to unit into all the calculations have been performed.

[Might not or move to another place]
Versat is technically a compiler, but the name is also used to describe the general architecture of the generated accelerator. Every accelerator generated by Versat contains a semi-fixed architecture that manages the interface between the dataflow circuit and the system. The dataflow circuit, however, is fully described by the user.

The programmer that intents to use Versat is responsible for describing the dataflow graph of the algorithms that it intends to implement.

## Basic Units [6]

Dataflow programming is defined by the connection of basic units of operation. From the POV of the circuit designer, units contain inputs, outputs and usually contain some internal logic to produce the output from the inputs.

Versat units are allowed to contain internal state and they can interact with the outside system by implementing certain interfaces, explaine in section []. This allows a CPU to communicate directly with units or the units to communicate directly with RAM.

All basic units supported by Versat are either simple Verilog operations, like addition and shifts, or are implemented as Verilog modules. Units implemented as modules can define a variety of interfaces that Versat is responsible to connect to the outside system.

The job of the programmer using Versat is to design complex units made of instantiating and connecting these basic units with themselves. Versat is capable of generating an accelerator given any Unit (altought generating an accelerator for a basic unit is rather pointless).

Versat comes with a set of default units that perform basic operations. They can be found in hardware/src/units. Nevertheless, if the need arises, anyone can make a custom unit an integrate it with Versat as long as the unit follows the interfaces expected by Versat [].

## Versat specification [7]

Complex units are designed by using a custom made language, which is for now simply called a Versat specification. The syntax is still fluctuating as Versat improves and potentially changes. Inspired by Verilog and C, the language is used to describe higher level units using a hierachical approach. Complex units are described by instantiating and connecting simpler units. Units can only instantiate previously defined units (prevents recursive instantiation, which is not permitted in dataflow designs - a unit cannot instantiate itself). 

Complex units can be of different types. Currently Versat supports 3 different complex unit types: module, merge and iterative. 

A Module unit type is a simple grouping of units and their connections with no other special meaning. A module definition is separated into two portions: The first portion is used to instantiate the module sub units and the second portion is used to describe their connections. Binary operations (like additions and shifts) can be described directly in the second portion, without having to declare them in the first portion, by using a syntax similar to assignment statements in languages like C. 

```verilog
// C style comments are allowed, including multiline comments using /* */

module SimpleExample(){ // Module definition with zero inputs
  // Use this portion to instantiate units
  // In this example, we are instantiating two Const units and one Reg unit.

  Const a; // Const is a simple unit that outputs a constant configurable value.
  Const b;
  Reg result; // Reg is similar to a hardware register, but more complex since it is an actual Versat unit. 

# // This separates instance declaration from interconnection statements
    
  addition = a + b; // One of two types of statements, this "assignment" like statement is used when performing basic operations (like binary operations and shifts)

  addition -> result; // The other type of statement is the "connection". We are connecting the output of addition the the input of result.
}
```

In this SimpleExample module, we define two Const units and one Reg unit. The Const units constantly output a single value. This value can be configured by software which we will see later on. The Reg unit is supposed to simulate a hardware register: internally it stores a value, which it outputs constantly, and contains an input that stores a new value from the input. 

Unlike normal registers however, the register does not store values every cycle. The accelerator works on command: The CPU must instruct the accelerator to start working at which point the accelerator will perform a "run". For this simple example, a run would take one cycle. At the end of the run, the Reg "result" would contain the value of the sum of the values of 'a' and 'b'. 

This module, like all modules defined using this language, can be used as the Top module for purposes of hardware generation. To generate the accelerator, the Versat program must be called, the file that contains this module needs to be passed through the command line and the name of this module 'SimpleExample' must be set as the top level module.

Specification files contain more complex syntax than the one shown here. Refer to section <>.

## Generated hardware and software

Versat generates header files that defines the interface to interact with the accelerator. The header defines the entire API for that particular accelerator. For the SimpleExample, the generated header file looks something like this:

```cpp
// The interface for each individual unit used is generated
// The config interface allows the firmware to set configuration data for each unit
typedef struct {
  int constant;
} ConstConfig;

// The header preserves the original hierarchy when generating the headers
typedef struct {
  ConstConfig a;
  ConstConfig b;
} SimpleExampleConfig;

// The state interface allows the firmware to read data exposed by the unit itself.
typedef struct {
  int value;
} RegState;

typedef struct {
  RegState result;
} SimpleExampleState;

extern volatile SimpleExampleConfig* accelConfig;
extern volatile SimpleExampleState*  accelState;

void versat_init(int baseAddress);
void RunAccelerator();
```

In order to make the configuration process as simple and efficient as possible we minimize function calls when possible and instead allow the firmware to write directly to the memory mapped registers of the accelerator. The SimpleExampleConfig and SimpleExampleState structs generated for the SimpleExample match directly with the interface of the generated accelerator. 

After calling the versat_init function, writing to members of the accelConfig pointer and reading from the accelState pointer will actual write and read from the accelerator memory mapped interface.

Versat tries to maintain the hierarchy defined in the specification file in the generation of theses structs.

More advanced software can build abstractions over the generated API by defining functions that take pointers to these structures. Look at the software/unitConfiguration.h file for examples [iob specific]. 

```cpp
int main(){
    versat_init(VERSAT_BASE); // Like other peripherals, Versat needs to be initialized by calling the versat_init function. This function must be the first function called before anything else.

    // Set values for the a and b constant units
    accelConfig->a.constant = 10;
    accelConfig->b.constant = 5;

    RunAccelerator(1); // After configurating everything, run the accelerator once.

    printf("Result: %d\n",accelState->result.value); // Outputs "Result: 15".
    return 0;
}
```

This is an example of a firmware exercising the accelerator generated from the SimpleExample module. Versat_init needs to be called first before anything else.

For this simple example, we configure the constant units with two simple values, run the accelerator once by calling the RunAccelerator function and we read the result of the computation by reading the state of the Reg unit.

RunAccelerator is a higher level function that starts the accelerator and then loops waiting for the accelerator to finish before returning. More advance usages of the accelerator allow the programmer to run the accelerator in the background while the firmaware keeps processing other parts of the code. This form of using the accelerator is further explained in section []

As shown in the example, Config interfaces are used to write data into the units and State interfaces are used to read data from units. Attempting to read data from a Config interface or writing data to a State interface causes undefined behaviour and can potentially lead to a system deadlock. It is the responsibility of the firmware designer to prevent this from occuring.

## Running simple example. [5]

While Versat, the program, is capable of working standalone, it is also integrated in the IOb-SoC framework. As a "peripheral" of IOb-SoC, the accelerators generated by Versat can be simulated, pc-emulated and compiled to run on FPGA.

Pc-emulaton is similar to simulation since Versat uses Verilator to compile the accelerator design into a C++ simulable model. This makes pc-emulation faster than simulation while preserving a good amount of RTL simulation accuracy. The interface between the accelerator and the system however needs to be emulated by a custom wrapper generated by Versat. This means that it is possible for the incorrect usage of the accelerator to produce bugs that are not detected in pc-emulation and only appear in simulation.

[Need to figure out how to integrate this with IOb-SoC]

[Put some example here]

[Rewrite this part to be more step driven] While Versat is attached to the IOb-SoC system, running in pc-emulation requires a few additional steps compared to simulation. Versat generates a few source files and a Makefile that needs to be integrated with the rest of the build system. To simplify the build process, the only additional step needed by the programmer is to include the VerilatorMake.mk file inside the normal software Makefile and to add the libaccel.a library as a target and add it to the process of compilation. Furthermore, if compiling C code, need to add the C++ runtime libray using -lstdc++, since the Versat runtime is made in C++. Furthermore, this requires Verilator.

## Custom units. [7]

As mentioned previously, Versat is capable of integrating custom made units. These units are considered basic units and can be instantiated like any other unit. Versat currently only handles Verilog designs and the units must implement specific interfaces in order to integrate properly with the generated accelerator.

The interfaces, wire formats expected and their usages are as follows:

```verilog

module ExampleCustomUnitWithAllInterfaces #(
    // Some of the parameters that the interface might need to support
    parameter DATA_W,
    parameter ADDR_W,
    parameter DELAY_W,
    parameter AXI_ADDR_W,
    parameter AXI_DATA_W,
    parameter LEN_W,
  )

  // Standard wire types 
  input clk,
  input rst,
  input run, // Only asserted for one cycle.
  input running, // Asserted while accelerator is running. To save energy, unit can "turn off" logic while this signal is deasserted.

  // Inputs and Outputs
  input [DATA_W-1:0] in0, // Input.
  (* versat_latency = T *) output [DATA_W-1:0] out0, // Output. Because Versat needs to calculate statically the amount of time data needs to traverse the dataflow graph, the user must indicate the amount of time it takes for the unit to produce valid data from the moment it receives valid data as input. This latency is passed through Versat using a Verilog attribute.

  output done; // This wire is used to indicate to the accelerator that the unit has finished performing all the operations. Only units that take a variable amount of time to finish need to implement this interface.

  // Delay - delays are used by Versat to indicate how many cycles the unit most wait before the input contains valid data.
  input [DELAY_W-1:0] delay0, 

  // Memory mapped - Simple memory mapped slave interface. Follows the especifications of the IOb native interface
  //                 Note that this interface is usually used when the accelerator is not running. Implementation must handle any usage of this interface at any time.
  input                 valid,
  output                rvalid,
  input  [DATA_W/8-1:0] wstrb,
  input  [  ADDR_W-1:0] addr,
  input  [  DATA_W-1:0] wdata,
  output [  DATA_W-1:0] rdata,

  // Databus interface - Interface that connects to RAM. Units can implement more than one such interface.
  //                     The databus interface is similar to a master AXI lite, with the exception that we must know the length of the transfer beforehand.
  //                     The last signal still exists, meaning that the unit does not need to keep track over how many transfers occured.
  //                     For more information, check the specifications of th AXI lite interface
  input                     databus_ready_0,
  output                    databus_valid_0,
  output [  AXI_ADDR_W-1:0] databus_addr_0,
  input  [  AXI_DATA_W-1:0] databus_rdata_0,
  output [  AXI_DATA_W-1:0] databus_wdata_0,
  output [AXI_DATA_W/8-1:0] databus_wstrb_0,
  output [       LEN_W-1:0] databus_len_0,
  input                     databus_last_0,

  // External memory 2P - Implements a two port memory interface to a memory that is instantiated by Versat.
  output [ANY_SIZE:0] ext_2p_addr_out_0,
  output [ANY_SIZE:0] ext_2p_data_out_0,
  output              ext_2p_write_0,
  output [ANY_SIZE:0] ext_2p_addr_in_0,
  input  [ANY_SIZE:0] ext_2p_data_in_0,
  output              ext_2p_read_0,

  // External memory DP - Implements a true dual port interface to a memory that is instantiated by Versat.
  //                      All these wires belong to the same interface. 
  output [ANY_SIZE:0] ext_dp_addr_0_port_0,
  output [ANY_SIZE:0] ext_dp_out_0_port_0,
  input  [ANY_SIZE:0] ext_dp_in_0_port_0,
  output              ext_dp_enable_0_port_0,
  output              ext_dp_write_0_port_0,
  output [ANY_SIZE:0] ext_dp_addr_0_port_1,
  output [ANY_SIZE:0] ext_dp_out_0_port_1,
  input  [ANY_SIZE:0] ext_dp_in_0_port_1,
  output              ext_dp_enable_0_port_1,
  output              ext_dp_write_0_port_1,

  // Config - Any input wire whose name does not match any other interface is treated as part of the Config interface
  input [ANY_SIZE:0] anyOtherName,

  // State - Same logic for State interfaces, except that the wire must be an output.
  output [ANY_SIZE:0] anyOtherName,

```

Any interface that contains a number on the end can be implemented multiple times by a single unit. The number must start at zero and increment by one for every extra interface.

The size of the wires must match what is shown. Units must also declare the parameters if they implement any interface that uses them.

For the external memories, the size used for address and data can differ between ports but the total amount of memory allocated must match. Versat automatically handles the instantiation of memories with different sizes, as for example:

```verilog
// Example where the address and data size match between ports. This memory can store 128 bits and contains ports that look at the memory has 16 x 8 bits.
output [3:0] ext_2p_addr_out_0,
output [7:0] ext_2p_data_out_0,

output [3:0] ext_2p_addr_in_0,
input  [7:0] ext_2p_data_in_0,

// Example with mismatched ports. This is a memory that is also capable of storing 128 bits in total, but with the difference that the write port sees it as 8 x 16 bits while the read port sees it as 16 x 8 bits.
output [2:0] ext_2p_addr_out_0,
output [15:0] ext_2p_data_out_0,

output [3:0] ext_2p_addr_in_0,
input  [7:0] ext_2p_data_in_0,
```

## Data validity and delays [6]

[This thing with static method is a little weird]
The accelerator generated by Versat uses a static method of handling data validity. Each unit that requires the ability to differenciate between valid data and garbage can do so by implementing the delay interface. The entire process of calculating the delays and making sure that the accelerator is correctly configured in this aspect is handled automatically by Versat. The end user should not need to know these details. 

This form of handling data validity guarantees that every unit receives valid data on all its inputs at the exact same time. Units do not need to delay or wait for other units as the accelerator is built with all the data arriving in the same cycle. Any path that is faster than the others is delayed so that data always arrives at the same time and units do not need to worry about storing inputs or having to implement backpreassure signals to stop data movements.

```verilog
module ValidityExample(){
  Mem slow;
  Mem fast;

  PipelineRegister pipe; // PipelineRegister is a simple unit that takes one cycle to output whatever value it contains on its input. It effectively delays data by one cycle.

  Reg result;
#
  slow -> pipe; // Data from slow is delayed by one cycle.

  sum = pipe + fast; // Pipe is one cycle delayed compared to fast. Versat automatically delays the 'fast' path by one cycle to ensure that both inputs arrive at the same time.

  sum ->result; // Versat guarantees that the value stored by result is equal to the addition of the first value outputted by fast and the first value outputted by slow
}
```

The ValidityExample showcases how data validity is handled by default. Regardless of how much time it takes to compute the value of a path, Versat guarantees that when multiple paths converge on a single unit, the unit will have all its inputs carrying valid data.

This approach is ideal for circuits where we only care about doing computations with the current values. However, if we require to perform operations with past values, it is possible to change the time that we expect the values by inserting manual delays.

```verilog
module DelayExample(){
    Mem mem;
# 
    // An expression of the form [unit]{N} is used to delay the arrival of the data by N cycles.
    // Remember, in dataflow paradigm, data is always being streamed at every cycle. 
    // For example, the first valid value from mem{3} is the fourth valid value outputted by mem. Next cycle, the value will be the fifth valid value from mem and so on.

    sum = mem{0} + mem{1} + mem{2} + mem{3}; // Sums four adjacent values from memory every cycle starting at first value outputted by mem.

    sum -> out;
}
```

In this example, we have a simple memory unit outputting a stream of values. In order to sum a portion of these values together, we add delays by using the {N} operation, where the delay is given by N. When thinking as streams of data, the delay is equivalent to shifting the stream N units. For example, if we assume that the unit 'mem' was configured to produce a stream of natural numbers starting from zero, then the accelerator computes the following values:

| Cycle | mem{0} | mem{1} | mem{2} | mem{3} | sum |
| ----- | ------ | ------ | ------ | ------ | --- |
|     0 |      0 |      1 |      2 |      3 |   6 |
|     1 |      1 |      2 |      3 |      4 |  10 |
|     2 |      2 |      3 |      4 |      5 |  14 |
|     3 |      3 |      4 |      5 |      6 |  18 |

## Databus interfaces [7]

Units that implement databus interfaces can access external RAM. This interface only works while the accelerator is running. Units that use databus interfaces cannot expect to complete a transfer in a fixed amount of time and must implement the "done" wire.

Since the databus interface does not work in a fixed time setting, using the databus interface to obtain data that is feed directly into the circuit does not work. Generally, any unit that uses the databus interface needs to perform transfers to memory or from memory. 

The default examples of using a databus interface is the VRead and VWrite units that come by default with Versat. The VRead units reads from RAM and outputs data to the circuit. The VWrite unit stores data from the circuit and writes to RAM.

Since these units cannot perform the transfers at the same time that they iteract with the circuit, they employ the usage of a internal memory to act as a buffer. While one portion of the memory is being written with data from RAM, the other portion is being read to ouput data to the circuit. In the next run, the write and read portions are flipped so that data is being read from where the previous run wrote to and vice versa.

[Could use an image here, no?]

## Memory mapping [6]

Memory mapping is an interface that allows software to interact with units as if writing to memory. Unlike the Config interface where the software stores some values in a register which is connected to the unit, the memory mapped interface allows direct communication between the CPU and the unit itself.

Memory mapping is usually used to handle infrequent large transfers of data, like initializing a lookup table unit or a memory unit. For these cases, a databus interface would be overkill since it is heavier and harder to use.  

For the most part, this is used to fill units that contain memories but do not implement databus interfaces (like LookupTables).

In order to support pc emulation, we cannot access memory mapped units in the same form we access configurations. All memory mapped accesses must be done by using specific functions defined in versat_accel.h.

Furthermore, large memory transfers should be performed by using the VersatMemoryCopy function, which can use an internal DMA to speedup the transfer. The DMA only supports transfers between memory and the accelerator. It does not support memory to memory or accelerator to accelerator transfers.

## Configuration shadow register [6]

The architecture used by Versat stores all the configurations of the units in a large register contained inside the accelerator. This register is later connected to the units and is the reason why the units do not need to store internally their configurations.

By default, Versat generates the accelerator with an additional configuration "shadow register" which allows the configuration register to be safely modified while the accelerator is running without affecting the current run results. Any change to the configuration register is only visible by the units at the beginning of the next run. 

To maximize performance, it is expected that software performs configuration of a run while the previous run is still executing.

In order to achieve this, the software must call the StartAccelerator function to start the accelerator and immediatly return, without waiting for the accelerator to stop. Afterwards, software is free to change configurations without affecting the current run. 

The function EndAccelerator waits for the accelerator to stop. It must be called before the software accesses any data that depends on the accelerator having finished, which includes the State and Memory Mapped interfaces as well as any memory that the accelerator is capable of writing to. 

## Configuration sharing. [4]

In order to facilitate the design of SIMD portions of code, we implement two ways of sharing the config interface between units. Note that units with shared configs are still individual working with their own inputs, outputs and internal states. Sharing configuration does not imply sharing any other interface. Only Config sharing is currently supported.

Of the two ways, the simplest is to define a set of units inside a module has having shared configs. We can only share configurations between units of the same type and as such the share construct is defined by using the share keyword, defining the type and then using a block to define all the shared instances.

Shared units constructed this way have their configurations shared directly inside the generated structures, by using a union instead of a struct. In general, when using shared units, the format of the generated struct is a good way of figuring out how the configuration is being shared inside the accelerator.

The second way is through the use of the word static before an instance declaration. Mimicking the concept found in object oriented languages, a static unit is bound to its parent module and every time the module is instantiated that units  shares its configuration with every instance that instantiates the parent module. Every instance of the module will instantiate the static unit that will contain the same configuration as every other instance of the same unit, regardless of the position on the hierarchy. 

Unlike configuration sharing, static units contain their own structure used to configure them. Static units are useful to implement registers that share constants instead of using extra inputs and outputs to pass the data into lower hiearchy units.

Versat spec:
```verilog
module StaticExample(){
    static Const const;
#
    constant -> out:0;   
}

module ShareExample(){
    share config Const {
        shared_0;
        shared_1;
    }
    StaticExample static_0;
    StaticExample static_1;
#
    {unit[0..1],static[0..1]} -> out:0..3;
}
```

Header generated:
```cpp
// The share units generate a structure that uses unions for the shared units configs
// The structure mimics the generated configuration register. Changing config of unit[0] is the same as changing the configuration of unit[1]. 
typedef struct {
  union{
    ConstConfig unit_0;
    ConstConfig unit_1;
  };
} ShareExampleConfig;

// Static on the other hand are extracted into a separate structure.
// There exists only one value, any instance of StaticExample will share the configuration of const with all other instances of StaticExample
typedef struct {
  int StaticExample_const_constant;
} ShareExampleStatic;
```

## Merge [6]

While implementing an algorithm using dataflow paradigms, it is useful to divide the algorithm into multiple parts that are each processed using its own accelerator. When using Versat, this would be the equivalent of defining multiple modules, one for each step of the algorithm and then grouping all this modules into a top level unit which would later be used to generate the final accelerator.

This methods works and it is possible to solve problems using this approach but it has its flaws. Since each module is associated to a given step of an algorithm, then that means that at any given point in the execution of the algorithm only one of the modules is being used. The other modules are not being used while still occuping resources. 

While the programmer could design the modules in such a way that they offer a way of sharing units, we also designed Versat to have the ability of performing this work automatically. We call this operation merge and like modules, merge defines new unit types which can they be used just like modules are.

```verilog
module Child1(){
  Const a;
  Const b;
# 
  ...  
}

module Child2(){
  Const x;  
#
  ... 
}

merge Merged = Child1 | Child2;
```

The merge operation is simple: We only need to describe which types we which to merge. In this example, Merged is just like any other type. It can be instantiated inside modules, it can be part of another merge, it can be used as the top level module for code generation.

```cpp
typedef struct {
  ConstConfig a;
  ConstConfig b;
} Child1Config;

typedef struct {
  ConstConfig x; // Since x is in the first slot of the structure, it means that Versat merged Child1.a with Child2.x
  int unused;    // Since the configuration is shared, some structures will have "unused" to pad data to fit their actual places.
} Child2Config;

/*
Note that Versat choose to merge Child1.a with Child2.x.
Since child1 contains two Consts, it would also be possible for Versat to merge Child1.b with Child2.x;
Which would produce the following structure:

typedef struct {
  int unused; 
  ConstConfig x;
} Child2Config;
*/

typedef struct {
  union { // It is a union. It matches the actual accelerator configuration register which is shared accross units depending on which units where merged
    Child1Config Child1;
    Child1Config Child2;
  };
} MergedConfig;

// The only extra step required for software writers it to inform the accelerator which unit is currently activated.
// The ActivateMergedAccelerator function needs to be called so that Versat can change the datapath so that the accelerator performs the operations associated to the given merged unit.

typedef enum{
    MergeType_Child1 = 0, MergeType_Child2 = 1  
} MergeType;

void ActivateMergedAccelerator(MergeType type);
```

In order to merge units, Versat needs to flatten the dataflow graphs into the most basic units. This means that hierarchy information is lost. However, when generating the software, Versat still tries to keep the hierarchy as much as possible. For this simple example, the generated structs for Child1Config and Child2Config are generated not to match their original configurations but to match the configurations from the point of view of the merged unit. This is the reason why Child2Config contains an "unused" extra member and its necessity is found by looking at what would happen if Versat merged Child1.b with Child2.x: Since unit 'b' of Child1 is the second configuration value, after the merge with Child2.x, the configuration of Child2.x must match the configuration of Child1.b. This is only possible if we add some padding.

Due to the fact that units can contain internal data and that the datapath can loop, it is helpful to have control over which units are merged or not. This can be accomplished by using an extended form of the merge construct. First, names need to be given to each type. [Finish this]

## Versat program

Versat itself is an executable that behaves like a compiler. It expects a specification file, the name of the Top level entity and it outputs all the previously mentioned files. A nix file allows versat to be compiled and run very easily by simply doing a CallPackage in the top nix file (as can be seen in default.nix) and afterwards, entering a nix-shell should compile and prepare the environment to utilize Versat. To run it individually, simply call ./versat.

For more information on running Versat individually, call versat and pass the -h flag.

[More information can be found by calling versat -h. (Need to do this)]

### Advance Specification syntax

Not shown in previous examples, but units can contain multiple inputs and outputs. This means that connections must encode the ports as well as the units. By default, if only the unit is specified, then the port being used is assumed to be port 0. Otherwise, the designer can specifie the ports as follows:

```verilog
module PortExample(x,y){ // This module contains two inputs.
    Mem mem; // Mem units contain two input ports and two output ports.
#
    x -> mem;   // Connects input named x to port 0 of mem.
    y -> mem:1; // Connects input named y to port 1 of mem. Note that in the previous connection we only used "mem" because by default we use port zero.

    {x,y} -> mem:0..1; // To simplify connections, we can group multiple expressions and use ranges to represent multiple ports.

    mem:0..1 -> out:0..1; // The out instance is a special named unit that represents the module output. It can have any amount of sequential ports.
}

module ModuleUsage(){
  PortExample example;

  Const constants[2];
  Reg result[2];
#
  constants[0..1] -> example:0..1;

  example:0..1 -> result[0..1];
}
```
