<!---

Versat is a Coarse Grained Reconfigurable Array (CGRA) IP core

## Cite this project

If you use this project please cite the following publication:

Lopes, J.D.; VÃ©stias, M.P.; Duarte , R.P.; Neto, H.C.; de Sousa , J.T. 
Coarse-Grained Reconfigurable Computing with the Versat Architecture. 
Electronics 2021, 10, 669. https://doi.org/10.3390/electronics10060669 
--->

# Dependencies

In order to compile Versat directly, the following tools should be installed:
- GNU Bash >=5.1.16
- GNU Make >=4.3
- GCC with C++17 support
- Verilator >= 5

Build systems that use nix-shell can simple add versat as a package and versat will be built when needed.

# Compile

Simple run 

```bash
make clean
make -j versat
```

to compile Versat into an executable. 

# Integrate Versat with IOb-SoC

Versat currently implements the python setup approach currently used by IOb-SoC in order to integrate with the rest of the SoC build system.

Since the actual accelerator is generated by Versat, the top level python setup script must create the python class that represents the generated accelerator.

This is done by calling the CreateVersatClass function, which returns a class specific to the generated accelerator and which acts like any other peripheral class. An example of integrating Versat with IOb-SoC can be found in the [iob-soc-versat](https://github.com/IObundle/iob-soc-versat) repository.

Versat also contains a nix package definition, whcih allows nix-shell users the ability to automatically enter an environment with all dependencies and versat compiled. An example of using this package can also be found in the [iob-soc-versat](https://github.com/IObundle/iob-soc-versat) repository.

# Versat Tutorial

At its core Versat is a compiler that transforms a high level specification into an accelerator. Versat takes as input a file that specifices units as dataflow graphs and the name of the top unit and Versat generates an coarse grained hardware accelerator based on the top unit design. Versat outputs hardware source files, written in Verilog, and software source and header files that allow software to configure the generated accelerator.

The specification is written in a custom language which is described in section [Versat specification](https://github.com/iobundle/iob-versat#Versat-specification). Versat is an executable and more information about its usage can be found by doing:

```bash
./versat -h
# or
./versat --help
```

## Dataflow paradigm

Versat is based on the dataflow paradigm of computation. In this form, computation is described by the movement of data accross units which perform operations on the data as it moves along them. In Versat, some units are sources of data, as the are the origin of data in the circuit; some units only perform computation, like additions and multiplications, which only produce data from data that they receive as input; and some units are sinks of data, only storing results that are later accessed by software, not outputting any data to the circuit.

The programmer that intents to use Versat to generate the hardware needs to describe the dataflow graph of the algorithms that it intends to implement. Describing a dataflow graph is as simple as describing the units, which are the nodes of the graph, and the connections between units, which are the edges. 

The dataflow graph can contain global loops, where the graph contains a loop that englobes the whole graph, but internal loops are not allowed. Versat will give an error in the cases where the graph specified is not supported.

## Basic Units

Dataflow programming is defined by the connection of basic units of operation. Units contain inputs, outputs and usually contain some internal logic to produce the output from the inputs.

All basic units supported by Versat are either simple Verilog operations, like addition and shifts, or are implemented as Verilog modules. Versat implements all the operations supported by Verilog and already contains a set of basic units that can be found in hardware/src/units.

Basic units can contain internal state, can contain any amount of inputs and/or outputs and can use a variety of interfaces to obtain data from the system. Versat only supports units that take a fixed amount of time to process data. When looking at units inputs and outputs, it is easier to think about them as streams of data that are manipulated by the units. Units that only contain outputs are called sources and they produce a stream of data. Units that contain inputs and outputs are called compute units and they create streams of data from input streams. And finally sink units, that only contain inputs, take in streams as inputs and do not produce anything to the circuit (they usually store data in memory). Thinking about stream processing is helpful to understand how Versat handles data validity accross the accelerator. This is further explained in section [Data validity and delays](https://github.com/iobundle/iob-versat#Data-validity-and-delays).

The job of the programmer using Versat is to design more complex units made of instantiating and connecting units with themselves. Basic units are the building blocks from which higher level units are created. Any unit that can be made by instantiating and interconnecting basic units should by designed using that approach so that Versat can automatically handle all the complexities of integrating the unit with the accelerator. However, if needed, any programmer can define their own set of basic units and integrate them with Versat. These custom units must implement certain interfaces in order to integrate with the accelerator generated by Versat. These interfaces and their format are explained in section [Custom units](https://github.com/iobundle/iob-versat#Custom-units).

## Versat specification

Complex units are designed by using a custom made language, which is for now simply called a Versat specification. The syntax is still fluctuating as Versat improves and potentially changes. Inspired by Verilog and C, the language is used to describe higher level units using a hierachical approach. Complex units are described by instantiating and connecting simpler units. Units can only instantiate previously defined units (prevents recursive instantiation, which is not permitted in dataflow designs - a unit cannot instantiate itself). 

Complex units can be of different types. Currently Versat supports 3 different complex unit types: module, merge and iterative. 

A Module unit type is a simple grouping of units and their connections with no other special meaning. A module definition is separated into two portions: The first portion is used to instantiate the module sub units and the second portion is used to describe their connections. Binary operations (like additions and shifts) can be described directly in the second portion, without having to declare them in the first portion, by using a syntax similar to assignments in languages like C. 

```verilog
// C style comments are allowed, including multiline comments using /* */

module SimpleExample(){ // Module definition with zero inputs
  // Use this portion to instantiate units
  // In this example, we are instantiating two Const units and one Reg unit.

  Const a; // Const is a simple unit that outputs a constant configurable value.
  Const b;
  Reg result; // Reg is similar to a hardware register, but more complex since it is an actual Versat unit. 

# // This separates instance declaration from interconnection statements
    
  addition = a + b; // One of two types of statements, this "assignment" like statement is used when performing basic operations (like binary operations and shifts)

  addition -> result; // The other type of statement is the "connection". We are connecting the output of addition the the input of result.
}
```

In this SimpleExample module, we define two Const units and one Reg unit. The Const units constantly output a single value. This value can be configured by software which we will see later on. The Reg unit is supposed to simulate a hardware register: internally it stores a value, which it outputs constantly, and contains an input that stores a new value from the input. 

Unlike normal registers however, the register does not store values every cycle. The accelerator works on command: The CPU must instruct the accelerator to start working at which point the accelerator will perform a "run". For this simple example, a run would take one cycle. At the end of the run, the Reg "result" would contain the value of the sum of the values of 'a' and 'b'. 

This module, like all modules defined using this language, can be used as the Top module for purposes of hardware generation. To generate the accelerator, the Versat program must be called, the file that contains this module needs to be passed through the command line and the name of this module 'SimpleExample' must be set as the top level module.

Specification files contain more complex syntax than the one shown here. Refer to section <>.

## Generated hardware and software

Versat generates header files that defines the interface to interact with the accelerator. The header defines the entire API for that particular accelerator. For the SimpleExample, the generated header file looks something like this:

```cpp
// The interface for each individual unit used is generated
// The config interface allows software to set configuration data for each unit
typedef struct {
  int constant;
} ConstConfig;

// The header preserves the original hierarchy when generating the headers
typedef struct {
  ConstConfig a;
  ConstConfig b;
} SimpleExampleConfig;

// The state interface allows software to read data exposed by the unit itself.
typedef struct {
  int value;
} RegState;

typedef struct {
  RegState result;
} SimpleExampleState;

extern volatile SimpleExampleConfig* accelConfig;
extern volatile SimpleExampleState*  accelState;

void versat_init(int baseAddress);
void RunAccelerator();
```

In order to make the configuration process as simple and efficient as possible we minimize function calls when possible and instead allow software to write directly to the memory mapped registers of the accelerator. The SimpleExampleConfig and SimpleExampleState structs generated for the SimpleExample match directly with the interface of the generated accelerator. 

Writing to members of the accelConfig pointer and reading from members of the accelState pointer will write and read from the accelerator memory mapped interface.

Versat tries to maintain the hierarchy defined in the specification file in the generation of theses structs. Software can build abstractions over the generated API by making functions that take pointers to these structures. For an example of this, look at the file [unitConfiguration.h]()https://github.com/IObundle/iob-soc-versat/blob/main/software/src/Tests/unitConfiguration.hpp) present in the iob-soc-versat repository.

```cpp
int main(){
    versat_init(VERSAT_BASE); // Like other peripherals, Versat needs to be initialized by calling the versat_init function. This function must be the first function called before anything else. Need to pass the base address of the accelerator

    // Set values for the a and b constant units
    accelConfig->a.constant = 10;
    accelConfig->b.constant = 5;

    RunAccelerator(1); // After configurating everything, run the accelerator once.

    printf("Result: %d\n",accelState->result.currentValue); // Outputs "Result: 15".
    return 0;
}
```

This is an example of software exercising the accelerator generated from the SimpleExample module. versat_init needs to be called first before anything else.

For this simple example, we configure the constant units with two simple values, run the accelerator once by calling the RunAccelerator function and we read the result of the computation by reading the state of the Reg unit.

RunAccelerator is a higher level function that starts the accelerator and then loops waiting for the accelerator to finish before returning. More advance usages of the accelerator allow the programmer to run the accelerator in the background while software keeps executing. This is further explained in section [Configuration shadow register](https://github.com/iobundle/iob-versat#Configuration-shadow-register).

As shown in the example, Config interfaces are used to write data into the units and State interfaces are used to read data from units. Attempting to read data from a Config interface or writing data to a State interface causes undefined behaviour and can potentially lead to a system deadlock. It is the responsibility of the programmer to prevent this from occuring.

## Running simple example

While Versat, the program, is capable of working standalone, it is also integrated in the IOb-SoC framework. As a "peripheral" of IOb-SoC, the accelerators generated by Versat can be simulated, pc-emulated and compiled to run on FPGA.

The simple example mentioned previously can be tested by cloning the [iob-soc-versat](https://github.com/IObundle/iob-soc-versat) and performing these steps inside the repository:

```bash
make clean pc-emul-run TEST=SimpleTest
make clean sim-run TEST=SimpleTest
make clean fpga-run TEST=SimpleTest
```

Check the README inside the iob-soc-versat repository beforehand to learn how to properly clone it and which dependencies are required to install.

## Pc emulation and IOb-SoC integration

Pc-emulaton is similar to simulation since Versat uses Verilator to compile the accelerator design into a C++ simulable model. This makes pc-emulation faster than simulation while preserving a good amount of RTL simulation accuracy. The only difference between pc-emulation and simulation is the interface between the accelerator and the system which needs to be emulated by a custom wrapper generated by Versat. This means that it is possible for the incorrect usage of the accelerator to produce bugs that are not detected in pc-emulation and only appear in simulation.

In order to integrate Versat pc-emulation with IOb-SoC, we need to make some changes to the build system:

```
Insert "-include VerilatorMake.mk" inside the software Makefile
Add libaccel.a as a prerequisite of the generated executable
Link '-lm libaccel.a -lstdc++' (in this order) when compiling the executable 
```

These changes can be found inside the [iob-soc-versat](https://github.com/IObundle/iob-soc-versat) repository. 

## Custom units

As mentioned previously, Versat is capable of integrating custom made units. These units are considered basic units and can be instantiated like any other unit. Versat currently only accepts Verilog designs and the units must implement specific interfaces in order to integrate properly with the generated accelerator.

The interfaces, wire formats expected and their usages are as follows:

```verilog

module ExampleCustomUnitWithAllInterfaces #(
    // Some of the parameters that the interface might need to support
    parameter DATA_W,
    parameter ADDR_W,
    parameter DELAY_W,
    parameter AXI_ADDR_W,
    parameter AXI_DATA_W,
    parameter LEN_W,
  )

  // Standard wire types 
  input clk,
  input rst,
  input run, // Only asserted for one cycle.
  input running, // Asserted while accelerator is running. To save energy, unit can "turn off" logic while this signal is deasserted.

  // Inputs and Outputs
  input [DATA_W-1:0] in0, // Input.
  (* versat_latency = T *) output [DATA_W-1:0] out0, // Output. Because Versat needs to calculate statically the amount of time data needs to traverse the dataflow graph, the user must indicate the amount of time it takes for the unit to produce valid data from the moment it receives valid data as input. This latency is passed through Versat using a Verilog attribute.

  output done; // This wire is used to indicate to the accelerator that the unit has finished performing all the operations. Only units that take a variable amount of time to finish need to implement this interface.

  // Delay - delays are used by Versat to indicate how many cycles the unit most wait before the input contains valid data.
  input [DELAY_W-1:0] delay0, 

  // Memory mapped - Simple memory mapped slave interface. Follows the especifications of the IOb native interface
  //                 Note that this interface is usually used when the accelerator is not running. Implementation must handle any usage of this interface at any time.
  input                 valid,
  output                rvalid,
  input  [DATA_W/8-1:0] wstrb,
  input  [  ADDR_W-1:0] addr,
  input  [  DATA_W-1:0] wdata,
  output [  DATA_W-1:0] rdata,

  // Databus interface - Interface that connects to RAM. Units can implement more than one such interface.
  //                     The databus interface is similar to a master AXI lite, with the exception that we must know the length of the transfer beforehand.
  //                     The last signal still exists, meaning that the unit does not need to keep track over how many transfers occured.
  //                     For more information, check the specifications of th AXI lite interface
  input                     databus_ready_0,
  output                    databus_valid_0,
  output [  AXI_ADDR_W-1:0] databus_addr_0,
  input  [  AXI_DATA_W-1:0] databus_rdata_0,
  output [  AXI_DATA_W-1:0] databus_wdata_0,
  output [AXI_DATA_W/8-1:0] databus_wstrb_0,
  output [       LEN_W-1:0] databus_len_0,
  input                     databus_last_0,

  // External memory 2P - Implements a two port memory interface to a memory that is instantiated by Versat.
  output [ANY_SIZE:0] ext_2p_addr_out_0,
  output [ANY_SIZE:0] ext_2p_data_out_0,
  output              ext_2p_write_0,
  output [ANY_SIZE:0] ext_2p_addr_in_0,
  input  [ANY_SIZE:0] ext_2p_data_in_0,
  output              ext_2p_read_0,

  // External memory DP - Implements a true dual port interface to a memory that is instantiated by Versat.
  //                      All these wires belong to the same interface. 
  output [ANY_SIZE:0] ext_dp_addr_0_port_0,
  output [ANY_SIZE:0] ext_dp_out_0_port_0,
  input  [ANY_SIZE:0] ext_dp_in_0_port_0,
  output              ext_dp_enable_0_port_0,
  output              ext_dp_write_0_port_0,
  output [ANY_SIZE:0] ext_dp_addr_0_port_1,
  output [ANY_SIZE:0] ext_dp_out_0_port_1,
  input  [ANY_SIZE:0] ext_dp_in_0_port_1,
  output              ext_dp_enable_0_port_1,
  output              ext_dp_write_0_port_1,

  // Config - Any input wire whose name does not match any other interface is treated as part of the Config interface
  input [ANY_SIZE:0] anyOtherName,

  // State - Same logic for State interfaces, except that the wire must be an output.
  output [ANY_SIZE:0] anyOtherName,

```

Any interface that contains a number on the end can be implemented multiple times by a single unit. The number must start at zero and increment by one for every extra interface. The only exception is the dp external memory interfaces where the number that identifies the interface apppears first, the last number is used to specify the port.

The size of the wires must match. Units must also declare the parameters if they implement any interface that uses them. 

For the external memories, the size used for address and data can differ between ports but the total amount of memory allocated must match. Versat automatically handles the instantiation of memories with different sizes, as for example:

```verilog
// Example where the address and data size match between ports. This memory can store 128 bits and contains ports that look at the memory has 16 x 8 bits.
output [3:0] ext_2p_addr_out_0,
output [7:0] ext_2p_data_out_0,

output [3:0] ext_2p_addr_in_0,
input  [7:0] ext_2p_data_in_0,

// Example with mismatched ports. This is a memory that is also capable of storing 128 bits in total, but with the difference that the write port sees it as 8 x 16 bits while the read port sees it as 16 x 8 bits.
output [2:0] ext_2p_addr_out_0,
output [15:0] ext_2p_data_out_0,

output [3:0] ext_2p_addr_in_0,
input  [7:0] ext_2p_data_in_0,
```

## Data validity and delays

To handle data validity problems, Versat precalculates how many cycles it takes for data to flow from unit to unit and delays faster paths to match slower paths if needed. Each unit that requires the ability to differenciate between valid data and garbage can do so by implementing the delay interface. The entire process of calculating the delays and making sure that the accelerator is correctly configured in this aspect is handled automatically by Versat. The end user should not need to know these details. 

This form of handling data validity guarantees that every unit receives valid data on all its inputs at the exact same time. Units do not need to delay or wait for other units as the accelerator is built such that all the valid data arrives in the same cycle. 

```verilog
module ValidityExample(){
  Mem slow;
  Mem fast;

  PipelineRegister pipe; // PipelineRegister is a simple unit that takes one cycle to output whatever value it contains on its input. It effectively delays data by one cycle.

  Reg result;
#
  slow -> pipe; // Pipe basically delays slow by one cycle.

  sum = pipe + fast; // Pipe is one cycle delayed compared to fast. Versat automatically delays the 'fast' path by one cycle to ensure that both inputs arrive at the same time.

  sum ->result; // Versat guarantees that the value stored by result is equal to the addition of the first value outputted by fast and the first value outputted by slow
}
```

The ValidityExample showcases how data validity is handled by default. Regardless of how much time it takes to compute the value of a path, Versat guarantees that when multiple paths converge on a single unit, the unit will have all its inputs carrying valid data on the same cycle. 

This approach is ideal for circuits where we only care about doing computations with the current values. However, if we require to perform operations with past values, it is possible to change the time that we expect the values by inserting manual delays.

```verilog
module DelayExample(){
    Mem mem;
# 
    // An expression of the form [unit]{N} is used to delay the arrival of the data by N cycles.
    // Remember, in dataflow paradigm, data is always being streamed at every cycle. 
    // For example, the first valid value from mem{3} is the fourth valid value outputted by mem. Next cycle, the value will be the fifth valid value from mem and so on.

    sum = mem{0} + mem{1} + mem{2} + mem{3}; // Sums four adjacent values from memory every cycle starting at first value outputted by mem.

    sum -> out;
}
```

In this example, we have a simple memory unit outputting a stream of values. In order to sum a portion of these values together, we add delays by using the {N} operation, where the delay is given by N. When thinking as streams of data, the delay is equivalent to shifting the stream N units. For example, if we assume that the unit 'mem' was configured to produce a stream of natural numbers starting from zero, then the accelerator computes the following values:

| Cycle | mem{0} | mem{1} | mem{2} | mem{3} | sum |
| ----- | ------ | ------ | ------ | ------ | --- |
|     0 |      0 |      1 |      2 |      3 |   6 |
|     1 |      1 |      2 |      3 |      4 |  10 |
|     2 |      2 |      3 |      4 |      5 |  14 |
|     3 |      3 |      4 |      5 |      6 |  18 |

## Databus interfaces

Units that implement databus interfaces can access external RAM. This interface only works while the accelerator is running. Units that use databus interfaces cannot expect to complete a transfer in a fixed amount of time and must implement the "done" wire.

Since the databus interface does not work in a fixed time setting, using the databus interface to obtain data that is feed directly into the circuit does not work. Generally, any unit that uses the databus interface needs to perform transfers to memory or from memory. 

The default examples of using a databus interface is the VRead and VWrite units that come by default with Versat. The VRead units reads from RAM and outputs data to the circuit. The VWrite unit stores data from the circuit and writes to RAM.

Since these units cannot perform the transfers at the same time that they iteract with the circuit, they employ the usage of a internal memory to act as a buffer. While one portion of the memory is being written with data from RAM, the other portion is being read to ouput data to the circuit. In the next run, the write and read portions are flipped so that data is being read from where the previous run wrote to and vice versa.

## Memory mapping

Memory mapping is an interface that allows software to interact with units as if writing to memory. Unlike the Config interface where the software stores some values in a register which is connected to the unit, the memory mapped interface allows direct communication between the CPU and the unit itself.

Memory mapping is usually used to handle infrequent large transfers of data, like initializing a lookup table unit or a memory unit. For these cases, a databus interface would be overkill since it is heavier and harder to use.  

For the most part, this is used to fill units that contain memories but do not implement databus interfaces (like LookupTables).

In order to support pc emulation, we cannot access memory mapped units in the same form we access configurations. All memory mapped accesses must be done by using specific functions defined in versat_accel.h.

Furthermore, large memory transfers should be performed by using the VersatMemoryCopy function, which can use an internal DMA to speedup the transfer. The DMA only supports transfers between memory and the accelerator. It does not support memory to memory or accelerator to accelerator transfers.

## Configuration shadow register

The architecture used by Versat stores all the configurations of the units in a large register contained inside the accelerator. This register is later connected to the units and is the reason why the units do not need to store internally their configurations.

By default, Versat generates the accelerator with an additional configuration "shadow register" which allows the configuration register to be safely modified while the accelerator is running without affecting the current run results. Any change to the configuration register is only visible by the units at the beginning of the next run. 

To maximize performance, it is expected that software performs configuration of a run while the previous run is still executing.

In order to achieve this, the software must call the StartAccelerator function to start the accelerator and immediatly return, without waiting for the accelerator to stop. Afterwards, software is free to change configurations without affecting the current run. 

The function EndAccelerator waits for the accelerator to stop. It must be called before the software accesses any data that depends on the accelerator having finished, which includes the State and Memory Mapped interfaces as well as any memory that the accelerator is capable of writing to. 

## Configuration sharing

In order to facilitate the design of SIMD portions of code, we implement two ways of sharing the config interface between units. Note that units with shared configs are still individual working with their own inputs, outputs and internal states. Sharing configuration does not imply sharing any other interface. Only Config sharing is currently supported.

Of the two ways, the simplest is to define a set of units inside a module has having shared configs. We can only share configurations between units of the same type and as such the share construct is defined by using the share keyword, defining the type and then using a block to define all the shared instances.

Shared units constructed this way have their configurations shared directly inside the generated structures, by using a union instead of a struct. In general, when using shared units, the format of the generated struct is a good way of figuring out how the configuration is being shared inside the accelerator.

The second way is through the use of the word static before an instance declaration. Mimicking the concept found in object oriented languages, a static unit is bound to its parent module and every time the module is instantiated that units  shares its configuration with every instance that instantiates the parent module. Every instance of the module will instantiate the static unit that will contain the same configuration as every other instance of the same unit, regardless of the position on the hierarchy. 

Unlike configuration sharing, static units contain their own structure used to configure them. Static units are useful to implement registers that share constants instead of using extra inputs and outputs to pass the data into lower hiearchy units.

Versat spec:
```verilog
module StaticExample(){
    static Const const;
#
    constant -> out:0;   
}

module ShareExample(){
    share config Const {
        shared_0;
        shared_1;
    }
    StaticExample static_0;
    StaticExample static_1;
#
    {unit[0..1],static[0..1]} -> out:0..3;
}
```

Header generated:
```cpp
// The share units generate a structure that uses unions for the shared units configs
// The structure mimics the generated configuration register. Changing config of unit[0] is the same as changing the configuration of unit[1]. 
typedef struct {
  union{
    ConstConfig unit_0;
    ConstConfig unit_1;
  };
} ShareExampleConfig;

// Static on the other hand are extracted into a separate structure.
// There exists only one value, any instance of StaticExample will share the configuration of const with all other instances of StaticExample
typedef struct {
  int StaticExample_const_constant;
} ShareExampleStatic;
```

## Merge

While implementing an algorithm using dataflow paradigms, it is useful to divide the algorithm into multiple parts that are each processed using its own accelerator. When using Versat, this would be the equivalent of defining multiple modules, one for each step of the algorithm and then grouping all this modules into a top level unit which would later be used to generate the final accelerator.

This methods works and it is possible to solve problems using this approach but it has its flaws. Since each module is associated to a given step of an algorithm, then that means that at any given point in the execution of the algorithm only one of the modules is being used. The other modules are not being used while still occuping resources. 

While the programmer could design the modules in such a way that they offer a way of sharing units, we also designed Versat to have the ability of performing this work automatically. We call this operation merge and like modules, merge defines new unit types which can they be used just like modules are.

```verilog
module Child1(){
  Const a;
  Const b;
# 
  ...  
}

module Child2(){
  Const x;  
#
  ... 
}

merge Merged = Child1 | Child2;
```

The merge operation is simple: We only need to describe which types we which to merge. In this example, Merged is just like any other type. It can be instantiated inside modules, it can be part of another merge, it can be used as the top level module for code generation.

```cpp
typedef struct {
  ConstConfig a;
  ConstConfig b;
} Child1Config;

typedef struct {
  ConstConfig x; // Since x is in the first slot of the structure, it means that Versat merged Child1.a with Child2.x
  int unused;    // Since the configuration is shared, some structures will have "unused" to pad data to fit their actual places.
} Child2Config;

/*
Note that Versat choose to merge Child1.a with Child2.x.
Since child1 contains two Consts, it would also be possible for Versat to merge Child1.b with Child2.x;
Which would produce the following structure:

typedef struct {
  int unused; 
  ConstConfig x;
} Child2Config;
*/

typedef struct {
  union { // It is a union. It matches the actual accelerator configuration register which is shared accross units depending on which units where merged
    Child1Config Child1;
    Child1Config Child2;
  };
} MergedConfig;

// The only extra step required for software writers it to inform the accelerator which unit is currently activated.
// The ActivateMergedAccelerator function needs to be called so that Versat can change the datapath so that the accelerator performs the operations associated to the given merged unit.

typedef enum{
    MergeType_Child1 = 0, MergeType_Child2 = 1  
} MergeType;

void ActivateMergedAccelerator(MergeType type);
```

In order to merge units, Versat needs to flatten the dataflow graphs into the most basic units. This means that hierarchy information is lost. However, when generating the software, Versat still tries to keep the same hierarchical structure as much as possible. For this simple example, the generated structs for Child1Config and Child2Config are generated not to match their original configurations but to match the configurations from the point of view of the merged unit. This is the reason why Child2Config contains an "unused" extra member and its necessity is found by looking at what would happen if Versat merged Child1.b with Child2.x: Since unit 'b' of Child1 is the second configuration value, after the merge with Child2.x, the position of Child2.x configuration must match the position of Child1.b. This is only possible if we add some padding.

### Advance Specification syntax

Not shown in previous examples, but units can contain multiple inputs and outputs. This means that connections must encode the ports as well as the units. By default, if only the unit is specified, then the port being used is assumed to be port 0. Otherwise, the designer can specifie the ports as follows:

```verilog
module PortExample(x,y){ // This module contains two inputs.
    Mem mem; // Mem units contain two input ports and two output ports.
#
    // This
    x -> mem;   // Connects input named x to port 0 of mem.
    y -> mem:1; // Connects input named y to port 1 of mem.

    // is equivalent to this
    x -> mem:0; // Connects input named x to port 0 of mem.
    y -> mem:1; // Connects input named y to port 1 of mem.

    // which is equivalent to this
    {x,y} -> mem:0..1; // To simplify connections, we can group multiple expressions and use ranges to represent multiple ports.

    mem:0..1 -> out:0..1; // The out instance is a special named unit that represents the module output. It can have any amount of sequential ports.
}

module ModuleUsage(){
  PortExample example; // PortExample contains two inputs and two outputs.

  Const constants[2]; // We can instantiate multiple units by using an array expression like in C
  Reg result[2];
#
  constants[0..1] -> example:0..1; // We can use ranges inside array expressions, inside delay expressions and inside port expressions

  example:0..1 -> result[0..1]; 
}
```

