`timescale 1ns / 1ps
`include "axi.vh"
`include "xversat.vh"
`include "xdefs.vh"

module @{accel.name.str} #(
      parameter ADDR_W = `ADDR_W,
      parameter DATA_W = `DATA_W,
      parameter AXI_ADDR_W = `AXI_ADDR_W
   )
   (

   input run,
   output done,

   #{for i accel.nInputs}
   input [DATA_W-1:0]              in@{i},
   #{end}

   #{for i accel.nOutputs}
   output [DATA_W-1:0]             out@{i},
   #{end}

   #{for i accel.nConfigs}
   #{set wire accel.configWires[i]}
   input [@{wire.bitsize-1}:0]     @{wire.name}_@{i},
   #{end}

   #{for i accel.nStates}
   #{set wire accel.stateWires[i]}
   output [@{wire.bitsize-1}:0]    @{wire.name}_@{i},
   #{end}

   #{for i accel.nDelays}
   input [31:0]                    delay@{i},
   #{end}

   #{if accel.doesIO}
   // Databus master interface
   input [`nIO-1:0]                m_databus_ready,
   output [`nIO-1:0]               m_databus_valid,
   output [`nIO*AXI_ADDR_W-1:0]    m_databus_addr,
   input [`nIO*`DATAPATH_W-1:0]    m_databus_rdata,
   output [`nIO*`DATAPATH_W-1:0]   m_databus_wdata,
   output [`nIO*`DATAPATH_W/8-1:0] m_databus_wstrb,
   #{end}

   #{if accel.memoryMapBytes}
   // data/control interface
   input                           valid,
   input [ADDR_W-1:0]              addr,
   input [DATA_W/8-1:0]            wstrb,
   input [DATA_W-1:0]              wdata,
   output                          ready,
   output reg [DATA_W-1:0]         rdata,
   #{end}

   input                           clk,
   input                           rst
   );

wire wor_ready;

wire [31:0] unitRdataFinal;
reg [31:0] stateRead;

// Memory access
#{if unitsMapped}
wire we = (|wstrb);
assign rdata = unitRdataFinal;
assign ready = wor_ready;
assign wor_ready = (|unitReady);
reg [@{unitsMapped - 1}:0] memoryMappedEnable;
wire[@{unitsMapped - 1}:0] unitReady;
wire [31:0] unitRData[@{unitsMapped - 1}:0];

wire [31:0] #{join ", "}#{for i unitsMapped} rdata_@{i} #{end}#{end};

assign unitRdataFinal = (#{join "|"}#{for i unitsMapped} unitRData[@{i}] #{end}#{end});
#{end}

wire [@{numberUnits - 1}:0] unitDone;

assign done = &unitDone;

wire [31:0] #{join ", "}#{for inst instances}#{for j inst.tempData->numberOutputs} output_@{inst.id}_@{j}#{end}#{end}#{end};

// Memory mapped
#{if unitsMapped}
always @*
begin
   memoryMappedEnable = {@{unitsMapped}{1'b0}};
   if(valid)
   begin
   #{for i unitsMapped}
      if(addr[@{memoryMappedUnitAddressRangeHigh}:@{memoryMappedUnitAddressRangeLow}] == @{i})
         memoryMappedEnable[@{i}] = 1'b1;
   #{end}
   end
end
#{end}

#{set counter 0}
#{set configDataIndex 0}
#{set stateDataIndex 0}
#{set ioIndex 0}
#{set memoryMappedIndex 0}
#{set configsSeen 0}
#{set statesSeen 0}
#{set inputSeen 0}
#{set delaySeen 0}
#{for inst instances}
#{set decl inst.declaration}
   @{decl->name.str} @{decl->name.str}_@{counter} (
      #{if decl->name.str == "circuitInput"}
         .in0(in@{inputSeen}),
      #{set inputSeen inputSeen + 1}
      #{end}

      #{if decl->name.str == "circuitOutput"}
      #{for i accel.nOutputs}
         .out@{i}(out@{i}),
      #{end}
      #{end}

      #{for i inst.tempData->numberOutputs}
         .out@{i}(output_@{inst.id}_@{i}),
      #{end} 

      #{for i inst.tempData->numberInputs}
         .in@{i}(output_@{inst.tempData->inputs[i].inst.inst->id}_@{inst.tempData->inputs[i].inst.port}),
      #{end}

      #{for i decl->nConfigs}
      #{set wire decl->configWires[i]}
         .@{wire.name}_@{i}(@{accel.configWires[configsSeen].name}_@{configsSeen}),
      #{inc configsSeen}
      #{end}

      #{for i decl->nDelays}
         .delay@{i}(delay@{delaySeen}),
      #{inc delaySeen}
      #{end}

      #{for i decl->nStates}
      #{set wire decl->stateWires[i]}
         .@{wire.name}(@{accel.stateWires[statesSeen].name}_@{statesSeen}),
      #{inc statesSeen}
      #{end}      

      #{if decl->memoryMapBytes}
      .valid(memoryMappedEnable[@{memoryMappedIndex}]),
      .wstrb(wstrb),
      .addr(addr[@{memoryMappedUnitAddressRangeHigh - 1}:0]),
      .rdata(unitRData[@{memoryMappedIndex}]),
      .ready(unitReady[@{memoryMappedIndex}]),
      .wdata(wdata),
      #{inc memoryMappedIndex}
      #{end}

      #{if decl->doesIO}
      .databus_ready(m_databus_ready[@{ioIndex}]),
      .databus_valid(m_databus_valid[@{ioIndex}]),
      .databus_addr(m_databus_addr[@{ioIndex}]),
      .databus_rdata(m_databus_rdata[@{ioIndex}]),
      .databus_wdata(m_databus_wdata[@{ioIndex}]),
      .databus_wstrb(m_databus_wstrb[@{ioIndex}]),
      #{inc ioIndex}
      #{end} 
      
      .run(run),
      .done(unitDone[@{counter}]),
      .clk(clk),
      .rst(rst)
   );

#{set counter counter + 1}
#{end}

endmodule
